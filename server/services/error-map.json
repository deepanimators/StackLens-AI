{
  "database_errors": {
    "connection_timeout": {
      "pattern": ["connection", "timeout", "database"],
      "severity": "high",
      "root_cause": "Database connection timeout due to network issues or database overload",
      "resolution_steps": [
        "Check database server status and connectivity",
        "Verify connection pool configuration",
        "Review database query performance",
        "Check network latency between application and database",
        "Consider increasing connection timeout values"
      ],
      "code_example": "// Increase connection timeout\nconst config = {\n  connectionTimeout: 30000,\n  requestTimeout: 30000\n};",
      "prevention_measures": [
        "Implement connection pooling",
        "Monitor database performance",
        "Set appropriate timeout values",
        "Use database connection health checks"
      ]
    },
    "syntax_error": {
      "pattern": ["syntax", "error", "sql", "query"],
      "severity": "medium",
      "root_cause": "SQL syntax error in database query",
      "resolution_steps": [
        "Review the SQL query syntax",
        "Check for missing commas, parentheses, or quotes",
        "Verify table and column names",
        "Use parameterized queries to prevent SQL injection",
        "Test queries in database management tool"
      ],
      "code_example": "// Correct SQL syntax\nconst query = 'SELECT * FROM users WHERE id = ?';\ndb.query(query, [userId]);",
      "prevention_measures": [
        "Use ORM or query builder",
        "Implement SQL linting",
        "Use parameterized queries",
        "Code review for database queries"
      ]
    }
  },
  "network_errors": {
    "connection_refused": {
      "pattern": ["connection", "refused", "network"],
      "severity": "high",
      "root_cause": "Network connection refused by target server",
      "resolution_steps": [
        "Check if target server is running",
        "Verify network connectivity",
        "Check firewall settings",
        "Verify correct port and hostname",
        "Check service availability"
      ],
      "code_example": "// Add retry logic with exponential backoff\nconst retry = async (fn, retries = 3) => {\n  try {\n    return await fn();\n  } catch (error) {\n    if (retries > 0) {\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      return retry(fn, retries - 1);\n    }\n    throw error;\n  }\n};",
      "prevention_measures": [
        "Implement retry logic",
        "Use health checks",
        "Monitor service availability",
        "Set up alerts for connection failures"
      ]
    },
    "timeout": {
      "pattern": ["timeout", "request", "response"],
      "severity": "medium",
      "root_cause": "Request timeout due to slow response or network issues",
      "resolution_steps": [
        "Check network latency",
        "Verify server response times",
        "Review timeout configuration",
        "Check for blocking operations",
        "Consider increasing timeout values"
      ],
      "code_example": "// Set appropriate timeout values\nconst response = await fetch(url, {\n  timeout: 10000,\n  signal: AbortSignal.timeout(10000)\n});",
      "prevention_measures": [
        "Set appropriate timeout values",
        "Implement caching",
        "Use asynchronous operations",
        "Monitor response times"
      ]
    }
  },
  "memory_errors": {
    "out_of_memory": {
      "pattern": ["memory", "heap", "out of memory", "oom"],
      "severity": "critical",
      "root_cause": "Application exceeded available memory limits",
      "resolution_steps": [
        "Increase memory allocation for the application",
        "Identify memory leaks in the code",
        "Optimize memory usage patterns",
        "Review large object allocations",
        "Implement garbage collection tuning"
      ],
      "code_example": "// Memory management best practices\nconst processLargeData = (data) => {\n  // Process data in chunks to avoid memory issues\n  const chunkSize = 1000;\n  for (let i = 0; i < data.length; i += chunkSize) {\n    const chunk = data.slice(i, i + chunkSize);\n    processChunk(chunk);\n  }\n};",
      "prevention_measures": [
        "Monitor memory usage",
        "Implement memory profiling",
        "Use streaming for large data",
        "Set appropriate memory limits"
      ]
    },
    "memory_leak": {
      "pattern": ["memory", "leak", "growing", "heap"],
      "severity": "high",
      "root_cause": "Memory leak causing gradual memory consumption increase",
      "resolution_steps": [
        "Use memory profiling tools",
        "Identify unreleased references",
        "Check for circular references",
        "Review event listener cleanup",
        "Optimize garbage collection"
      ],
      "code_example": "// Proper cleanup of event listeners\nconst cleanup = () => {\n  window.removeEventListener('resize', handleResize);\n  clearInterval(intervalId);\n};",
      "prevention_measures": [
        "Implement proper cleanup",
        "Use weak references where appropriate",
        "Monitor memory growth",
        "Regular memory profiling"
      ]
    }
  },
  "file_system_errors": {
    "file_not_found": {
      "pattern": ["file", "not found", "enoent", "path"],
      "severity": "medium",
      "root_cause": "Attempted to access a file that doesn't exist",
      "resolution_steps": [
        "Verify file path is correct",
        "Check file permissions",
        "Ensure file exists before accessing",
        "Use absolute paths when possible",
        "Implement file existence checks"
      ],
      "code_example": "// Check file existence before accessing\nconst fs = require('fs').promises;\n\nconst readFileIfExists = async (filePath) => {\n  try {\n    await fs.access(filePath);\n    return await fs.readFile(filePath, 'utf8');\n  } catch (error) {\n    if (error.code === 'ENOENT') {\n      console.log('File not found:', filePath);\n      return null;\n    }\n    throw error;\n  }\n};",
      "prevention_measures": [
        "Validate file paths",
        "Use file existence checks",
        "Implement proper error handling",
        "Use configuration for file paths"
      ]
    },
    "permission_denied": {
      "pattern": ["permission", "denied", "access", "eacces"],
      "severity": "medium",
      "root_cause": "Insufficient permissions to access file or directory",
      "resolution_steps": [
        "Check file/directory permissions",
        "Verify user has required access rights",
        "Use appropriate user account",
        "Check parent directory permissions",
        "Review security policies"
      ],
      "code_example": "// Handle permission errors gracefully\nconst handleFileAccess = async (filePath) => {\n  try {\n    return await fs.readFile(filePath, 'utf8');\n  } catch (error) {\n    if (error.code === 'EACCES') {\n      console.error('Permission denied:', filePath);\n      // Implement fallback or request elevated permissions\n    }\n    throw error;\n  }\n};",
      "prevention_measures": [
        "Set appropriate file permissions",
        "Use service accounts properly",
        "Implement permission checks",
        "Document required permissions"
      ]
    }
  },
  "runtime_errors": {
    "null_reference": {
      "pattern": ["null", "undefined", "reference", "cannot read"],
      "severity": "high",
      "root_cause": "Attempted to access property or method on null or undefined value",
      "resolution_steps": [
        "Add null/undefined checks",
        "Use optional chaining",
        "Initialize variables properly",
        "Implement defensive programming",
        "Use TypeScript for better type safety"
      ],
      "code_example": "// Safe property access\nconst getValue = (obj) => {\n  return obj?.property?.value || 'default';\n};\n\n// Or traditional null check\nif (obj && obj.property) {\n  return obj.property.value;\n}",
      "prevention_measures": [
        "Use TypeScript",
        "Implement null checks",
        "Use optional chaining",
        "Initialize variables properly"
      ]
    },
    "type_error": {
      "pattern": ["type", "error", "is not a function", "is not defined"],
      "severity": "high",
      "root_cause": "Type mismatch or undefined function/variable",
      "resolution_steps": [
        "Check variable types",
        "Verify function definitions",
        "Check import/export statements",
        "Use type checking",
        "Review variable scope"
      ],
      "code_example": "// Type checking example\nconst processData = (data) => {\n  if (typeof data !== 'object' || data === null) {\n    throw new Error('Data must be an object');\n  }\n  if (typeof data.process !== 'function') {\n    throw new Error('Data must have a process method');\n  }\n  return data.process();\n};",
      "prevention_measures": [
        "Use TypeScript",
        "Implement type checking",
        "Use linting tools",
        "Add unit tests"
      ]
    }
  },
  "configuration_errors": {
    "missing_config": {
      "pattern": ["config", "missing", "environment", "variable"],
      "severity": "high",
      "root_cause": "Missing or undefined configuration values",
      "resolution_steps": [
        "Check environment variables",
        "Verify configuration files",
        "Set default values",
        "Use configuration validation",
        "Check deployment settings"
      ],
      "code_example": "// Configuration validation\nconst config = {\n  port: process.env.PORT || 3000,\n  dbUrl: process.env.DATABASE_URL || (() => {\n    throw new Error('DATABASE_URL is required');\n  })()\n};\n\n// Validate required config\nconst requiredConfig = ['DATABASE_URL', 'API_KEY'];\nfor (const key of requiredConfig) {\n  if (!process.env[key]) {\n    throw new Error(`Missing required environment variable: ${key}`);\n  }\n}",
      "prevention_measures": [
        "Use configuration validation",
        "Set default values",
        "Document required configuration",
        "Use configuration management tools"
      ]
    }
  }
}